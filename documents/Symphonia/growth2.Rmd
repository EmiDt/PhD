---
title: "Symphonia growth"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(flexdashboard)
library(rgdal)
library(raster)
library(leaflet)
library(starmie)
library(rstan)
library(bayesplot)
library(abind)
library(tidyverse)
mpath <- "/home/sylvain/Documents/BIOGECO/PhD/documents/Symphonia/symphonia_models/"
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
    cache = T, cache.lazy = F)
```

# Intro

```{r data}
source("~/Documents/BIOGECO/PhD/scripts/dbh_correction.R")
path <- "/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/"
trees <- read.csv(file.path(path, 'trees/Symphonia_Paracou.csv'),
                  dec=",", stringsAsFactors = F)
trees <- trees %>% # dbh correction
  filter(n_parcelle %in% 1:16) %>% 
    mutate(treatment = c(c('C', 'T1', 'T2', 'T3', 
                         'T2', 'C', 'T1', 'T3',
                         'T1', 'T2', 'C', 'T3'), 
                       rep('B', 4))[n_parcelle]) %>% 
  mutate(dbh = circonf/pi) %>% 
  group_by(idArbre) %>% 
  mutate(dbh_c = correction(dbh, campagne, code_vivant, code_mesure)) %>% 
  ungroup()
trees <- trees %>% # tree selection
  filter(treatment != 'B') %>% 
  arrange(campagne) %>% 
  group_by(idArbre) %>% 
  mutate(dt = campagne - lag(campagne)) %>% 
  mutate(ddbh = dbh_c - lag(dbh_c)) %>% 
  filter(dt > 0) %>% 
  filter(ddbh >= 0) %>% 
  mutate(agr = ddbh/dt) %>% 
  select(idArbre, n_parcelle, n_carre, n_arbre, Xutm, Yutm, dbh_c, agr)
path <- "/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/"
# global crs definition
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0'
# gaps
gaps <- shapefile("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/logging/Gaps.shp")
gaps <- spTransform(gaps, CRSobj = crs)
gaps$area <- area(gaps)
# trees
treesXY <- trees %>%
  select(-dbh_c, - agr) %>%
  distinct()
coordinates(treesXY) <- ~Xutm + Yutm
proj4string(treesXY) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
treesXY <- spTransform(treesXY, CRSobj = crs)
# gap distance
D <- rgeos::gDistance(spTransform(gaps, "+proj=utm +zone=22 +units=m"),
                      spTransform(treesXY, "+proj=utm +zone=22 +units=m"),
                      byid = T)
trees <- trees %>%
  left_join(data.frame(idArbre = treesXY$idArbre,
                       Did = as.numeric(row.names(D))))
mdata <- list(I = dim(trees)[1], # Nb of measurements
              AGR = trees$agr, # growth vector
              dbh = trees$dbh_c/max(trees$dbh_c), # dbh in 1988 vector
              J = dim(gaps)[1], # Nb of gaps
              S = gaps$area/max(gaps$area), # gaps surface vector
              K = dim(D)[1], # Nb of individuals
              D = D/max(D), # tree-gaps distance matrix
              ind = trees$Did) # Individual number in matrix D
rm(crs, path, correction, detect)
```

## Models

> I wanted to test for an eventual effect of logging through light and disturbance on Symphonia individuals growth. I combined the disturbance indice of model proposed by @Herault2010:
$$AGR_i \sim \mathcal{N}(\mu*\sum_j^J(e^{-\alpha*d_{i,j}}*S_j^\beta);\sigma)~|~i\in[1:I]~,~j\in[1:J]$$
with the potential reductor model proposed by @herault_functional_2011:
$$log(AGR_i+1) \sim \mathcal{N}(AGR_{max}*e^{-\frac{1}{2}*log(\frac{dbh_i}{d_{opt}/k_s})};\sigma)~|~i\in[1:I]$$
into:
$$log(AGR_i+1) \sim \mathcal{N}(AGR_{max}*e^{-\frac{1}{2}*log(\frac{dbh_i}{d_{opt}/k_s})}*e^{-\sum_j^Je^{-\alpha*d_{i,j}}*S_j^\beta};\sigma)~|~i\in[1:I]~,~j\in[1:J]$$
That I declined in different versions :

### Table 1: Models summary.

```{r}
mtab <- data.frame(
  M = c('$M_{1}$'),
  Model = c(
    '$log(AGR_i+1) \\sim \\mathcal{N}(AGR_{max}*e^{-\\frac{1}{2}*log(\\frac{dbh_i}{d_{opt}/k_s})}*e^{-\\sum_j^Je^{-\\alpha*d_{i,j}}*S_j^\\beta};\\sigma)$'
  )
)
mtab$M <- as.character(mtab$M)
mtab$Model <- as.character(mtab$Model)
row.names(mtab) <- c('M1')
kable(mtab, row.names = F)
```

## Map

```{r map}
leaflet() %>%
  addPolygons(data = gaps, opacity = 0.5, col = 'green') %>% 
  addCircles(data = treesXY, radius = 0.2,
             label = paste0('P', treesXY$n_parcelle, '-',
                            treesXY$n_carre, '-',
                            treesXY$n_arbre))
rm(d, treesXY)
```

# `r mtab['M1',1]`

```{r M1}
fit <- stan(file = file.path(mpath, 'N1.stan'), data = mdata, chains = 1)
save(fit, file = file.path(mpath, 'N1.Rdata'))
# load(file.path(mpath, 'N1.Rdata'))
# pars <- c("AGRmax", "dopt", "ks", "alpha", "beta", "sigma")
# pars_val <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),pars]
```

## Column 1 {data-width=200}

<!-- > The model seems to have correctly converged but the pair plot shows a strong correlation between $\alpha$ and $\beta$ parameters certainly due to a confounded factor. This correlation have ot be corrected including more parameters. -->

### Model Predictions.

```{r M1 pred}
# P <- function(d, s, dmax, smax, pars_val)
#   rnorm(1000,
#          mean = sum(exp(-pars_val[1]*(d/dmax))*(s/smax)^pars_val[2]),
#          sd = pars_val[3])
# pred<- sapply(seq_len(mdata$I), function(i)
#   apply(as.matrix(fit)[,pars], 1, function(p)
#     P(D[i,], gaps$area, max(D), max(gaps$area), p)))
# pred <- data.frame(t(apply(pred, 2, function(x) quantile(x, probs = c(0.05, 0.95)))))
# pred$mean <- sapply(seq_len(mdata$I), function(i)
#                     sum(exp(-pars_val[1]*(D[i,]/max(D)))*(gaps$area/max(gaps$area))^pars_val[2]))
# pred$gaps <- apply(D, 1, min)
# pred$dbh <- mdata$dbh
# names(pred)[1:2] <- c('5%', '95%')
# save(pred, file = file.path(mpath, 'N1p.Rdata'))
# load(file.path(mpath, 'N1p.Rdata'))
# ggplot(data.frame(dgaps = apply(D, 1, min),
#                   growth = trees$growth),
#        aes(dgaps, growth)) +
#   geom_ribbon(aes(x = pred$gaps, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
#   geom_line(aes(x = pred$gaps, y = pred$`5%`, color = '5%'), linetype = 2) +
#   geom_line(aes(x = pred$gaps, y = pred$`95%`, color = '95%'), linetype = 2) +
#   geom_line(aes(x = pred$gaps, y = pred$mean, color = 'mean'), linetype = 2) +
#   geom_point() +
#   xlab('distance to the closest logging gap (m)') +
#   ylab('growth between 1988 and 1992 (cm)') +
#   scale_color_manual(name = 'Model',
#                      values = c('5%' = 'black',
#                                 '95%' = 'black',
#                                 'mean' = 'red'))
```

### Parameters markov chains.

```{r C1}
mcmc_trace(as.matrix(fit)[,c(pars, "lp__")], facet_args = list(labeller = label_parsed))
```

## Column 2 {data-width=200}

> `r paste(mtab['M1',], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*

```{r R1}
mcmc_areas(as.matrix(fit)[,pars],  prob = 0.8)
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*

```{r P1}
GGally::ggpairs(data.frame(as.matrix(fit)[,pars]))
```


# Conclusion

# References